from sklearn.model_selection import train_test_split
import pandas as pd
from utils.dataprocessor import process_malware
from script.individual import Individual
import random

class Population:

    def __init__(self, size, mutation_rate, feature_num, max_generations, crossover_rate, tournament_size, file_path):
        self.population = []
        self.generations = 0
        self.feature_num = feature_num
        self.mutation_rate = mutation_rate
        self.max_generations = max_generations
        self.crossover_rate = crossover_rate
        self.tournament_size = tournament_size
        self.best_ind = None
        self.best_ind_score = 0.0
        self.finished = False
        self.perfect_score = 0.90
        self.max_fitness = 0.0
        self.average_fitness = 0.0
        self.mating_pool = []
        self.x_train, self.x_test, self.y_train, self.y_test = self.data_spliter(filepath=file_path)

        self.avg_arr = []
        self.best_model = None
        self.best_arr = []

        self.create_initial_population(size, feature_num)

    def data_spliter(self, filepath):
        df = process_malware(filepath)
        x = df.drop(['class'], axis=1)
        y = df['class']
        return train_test_split(x, y, test_size=0.33, random_state=42)

    def create_initial_population(self, size, feature_num):
        for i in range(size + 1):
            ind = Individual(feature_num)
            ind.calc_fitness(self.x_train, self.y_train)
            if ind.fitness > self.max_fitness:
                self.max_fitness = ind.fitness
            self.average_fitness += ind.fitness
            self.population.append(ind)
        self.average_fitness /= size

    def print_population_status(self):
        print("\nGeneration " + str(self.generations))
        print("Average fitness: " + str(self.average_fitness))
        print("Best individual: " + str(self.best_ind))
        self.avg_arr.append(self.average_fitness)
        self.best_arr.append(self.best_ind_score)

    def natural_selection(self):
        self.generate_next_population()
        self.evaluate()

    def generate_next_population(self):
        population_len = len(self.population)
        new_population = []
        self.average_fitness = 0.0

        for i in range(population_len):
            parent_a, parent_b = self.tournament_selection()

            if random.random() <= self.crossover_rate:
                offspring = parent_a.crossover(parent_b)
            else:
                offspring = parent_a if random.random() <= 0.5 else parent_b

            # Perform the gene mutation
            offspring.mutate(self.mutation_rate)

            offspring.calc_fitness(self.x_train, self.y_train)

            self.average_fitness += offspring.get_fitness()
            new_population.append(offspring)

        self.population = new_population
        self.generations += 1
        self.average_fitness /= len(new_population)

    def tournament_selection(self):
        tournament_arr = random.sample(self.population, self.tournament_size)
        tournament_arr.sort(key=lambda x: x.get_fitness(), reverse=True)
        return tournament_arr[0], tournament_arr[1]

    # Wheel selection
    # def wheel_selection(self):
    #     for index, ind in enumerate(self.population):
    #         prob = int(round(ind.fitness * 100)) - 90
    #         self.mating_pool.extend([index for i in range(prob)])
    #     return random.sample(self.mating_pool, 2)

    def evaluate(self):
        best_fitness = 0.0

        for ind in self.population:
            if ind.fitness > best_fitness:
                best_fitness = ind.fitness
                self.best_ind = ind
                self.best_ind_score = ind.fitness
                self.best_model = ind.get_model()

        # check the stop condition
        if best_fitness >= self.perfect_score or self.generations == self.max_generations:
            self.finished = True